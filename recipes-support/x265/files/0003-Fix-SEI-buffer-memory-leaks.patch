From 56f7026cbdc3eb2c55078b22cb76817294419bd0 Mon Sep 17 00:00:00 2001
From: Min Chen <chenm003@163.com>
Date: Thu, 28 Nov 2024 16:09:28 -0800
Subject: [PATCH 03/13] Fix SEI buffer memory leaks

Upstream-Status: Backport
---
 source/encoder/encoder.cpp | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/source/encoder/encoder.cpp b/source/encoder/encoder.cpp
index 2e65cb1a9..e3285bbae 100644
--- a/source/encoder/encoder.cpp
+++ b/source/encoder/encoder.cpp
@@ -1082,6 +1082,16 @@ void Encoder::copyUserSEIMessages(Frame *frame, const x265_picture* pic_in)
     }
 
     int numPayloads = pic_in->userSEI.numPayloads + toneMapPayload + userPayload;
+
+    // TODO: we may reuse buffer if become smaller than exist buffer
+    if (frame->m_userSEI.payloads && numPayloads != frame->m_userSEI.numPayloads)
+    {
+        for (int i = 0; i < frame->m_userSEI.numPayloads; i++)
+            delete[] frame->m_userSEI.payloads[i].payload;
+        delete[] frame->m_userSEI.payloads;
+        frame->m_userSEI.payloads = NULL;
+    }
+
     frame->m_userSEI.numPayloads = numPayloads;
 
     if (frame->m_userSEI.numPayloads)
@@ -1102,6 +1112,12 @@ void Encoder::copyUserSEIMessages(Frame *frame, const x265_picture* pic_in)
             else
                 input = pic_in->userSEI.payloads[i];
 
+            // TODO: condition may improve, because buffer size may change from big to small, but never back to original allocate size
+            if (frame->m_userSEI.payloads[i].payload && frame->m_userSEI.payloads[i].payloadSize < input.payloadSize)
+            {
+                delete[] frame->m_userSEI.payloads[i].payload;
+                frame->m_userSEI.payloads[i].payload = NULL;
+            }
             if (!frame->m_userSEI.payloads[i].payload)
                 frame->m_userSEI.payloads[i].payload = new uint8_t[input.payloadSize];
             memcpy(frame->m_userSEI.payloads[i].payload, input.payload, input.payloadSize);
-- 
2.48.1

